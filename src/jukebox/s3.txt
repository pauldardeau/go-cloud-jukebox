package jukebox

import (
   //"context"
   "errors"
   "fmt"
   "github.com/aws/aws-sdk-go/aws"
   //"github.com/aws/aws-sdk-go-v2/config"
   "github.com/aws/aws-sdk-go/aws/session"
   //"github.com/aws/aws-sdk-go/service/s3"
   //"github.com/aws/aws-sdk-go-v2/service/s3"
   //"github.com/aws/aws-sdk-go-v2/credentials"
   "github.com/aws/aws-sdk-go/service/s3"
   "github.com/aws/aws-sdk-go/credentials"
)

// https://docs.aws.amazon.com/sdk-for-go/api/service/s3/
// https://docs.aws.amazon.com/sdk-for-go/api/service/s3/#pkg-examples
// https://github.com/mathisve/golang-AWS-S3-SDK-Example/blob/master/main.go

type S3StorageSystem struct {
   AbstractStorageSystem
   awsAccessKey string
   awsSecretKey string
   containerPrefix string
   s3Session *s3.Client
}


func NewS3StorageSystem(accessKey string,
                        secretKey string,
                        cnrPrefix string,
                        debugMode bool) *S3StorageSystem {

   ss := S3StorageSystem {
      AbstractStorageSystem{
         DebugMode: debugMode,
         Authenticated: false,
         CompressFiles: false,
         EncryptFiles: false,
         ListContainerNames: []string{},
         ContainerPrefix: "",
         MetadataPrefix: "",
         StorageSystemType: "S3",
      },
      accessKey,
      secretKey,
      cnrPrefix,
      nil,
    }

    if debugMode {
        fmt.Printf("Using accessKey='%s', secretKey='%s'\n", accessKey, secretKey)
    }

    if len(cnrPrefix) > 0 {
        if debugMode {
            fmt.Printf("using containerPrefix='%s'\n", cnrPrefix)
        }
    }

    return &ss 
}

func (ss *S3StorageSystem) Enter() bool {
    connected := false
    if ss.DebugMode {
        fmt.Println("attempting to connect to S3")
    }

    s3Config := aws.Config{
        Credentials:      credentials.NewStaticCredentials(s3SS.awsAccessKey, s3SS.awsSecretKey, ""),
        Endpoint:         aws.String("https://s3.wasabisys.com"),
        Region:           aws.String("us-central-1"),
        S3ForcePathStyle: aws.Bool(true),
    }

    session, err := session.NewSessionWithOptions(session.Options{
        Config: s3Config,
    })
    if err != nil {
        fmt.Println("unable to establish S3 session")
    } else {
        s3Client := s3.New(session)

        fmt.Println("established S3 session")
        ss.s3Session = s3Client
        connected = true
    }

/*
    creds := credentials.NewStaticCredentialsProvider(s3_ss.aws_access_key,
                                                      s3_ss.aws_secret_key,
                                                      "")
    endpoint := "https://s3.us-central-1.wasabisys.com"

    //config := aws.Config{
    //    Credentials: creds,
    //    Endpoint: &endpoint,
    //}

    cfg, err := config.LoadDefaultConfig(context.TODO(),
                                         config.WithCredentialsProvider(creds),
                                         config.WithEndpoint(endpoint))
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    awsS3Client := s3.NewFromConfig(cfg)
    */
/*
    sess, err := session.NewSession(&config)
    if err != nil {
        fmt.Println("unable to establish S3 session")
    } else {
        fmt.Println("established S3 session")
        s3Session = sess
        connected = true
    }
    */

    if connected {
        ss.Authenticated = true
        list_buckets, err := ss.ListAccountContainers()
        if err == nil {
            ss.ListContainerNames = *list_buckets
        }
    }

    return connected
}

func (ss *S3StorageSystem) Exit() {
    if ss.s3Session != nil {
        if ss.DebugMode {
            fmt.Println("closing S3 connection object")
        }

        ss.Authenticated = false
        ss.ListContainerNames = nil
        ss.s3Session = nil
    }
}

func (ss *S3StorageSystem) ListAccountContainers() (*[]string, error) {
    if ss.DebugMode {
        fmt.Println("ListAccountContainers")
    }

    if ss.s3Session != nil {
        /*
        input := &s3.ListBucketsInput{}

        result, err := s3_ss.s3_session.ListBuckets(input)
        if err != nil {
            if aerr, ok := err.(awserr.Error); ok {
                switch aerr.Code() {
                    default:
                        fmt.Println(aerr.Error())
                }
            } else {
                // Print the error, cast err to awserr.Error to get the Code and
                // Message from an error.
                fmt.Println(err.Error())
            }
            err := errors.New("ListBuckets not implemented")
            return nil, err
        } else {
            list_container_names := []string{}
            for _, bucket := range result.Buckets {
                container_name := *bucket.Name
                list_container_names = append(list_container_names,
                                              s3_ss.Un_prefixed_container(container_name))
            }

            return &list_container_names, nil
        }
        */
        return nil, errors.New("ListBuckets not implemented")
    }

    err := errors.New("No existing S3 session")

    return nil, err
}

func (ss *S3StorageSystem) CreateContainer(containerName string) bool {
    if ss.DebugMode {
        fmt.Printf("CreateContainer: '%s'\n", containerName)
    }

    containerCreated := false

    if ss.s3Session != nil {
       /*
       resp, err := ss.s3Session.CreateBucket(&s3.CreateBucketInput{
          Bucket: aws.String(BUCKET_NAME),
          CreateBucketConfiguration: &s3.CreateBucketConfiguration{
             LocationConstraint: aws.String(REGION),
          },
       })

       if err != nil {
          if aerr, ok := err.(awserr.Error); ok {
             switch aerr.Code() {
            case s3.ErrCodeBucketAlreadyExists:
        fmt.Println("Bucket name already in use!")
        panic(err)
      case s3.ErrCodeBucketAlreadyOwnedByYou:
        fmt.Println("Bucket exists and is owned by you!")
      default:
        panic(err)
           }
       }
       */
    }

    if containerCreated {
       ss.AddContainer(containerName)
    }

    return containerCreated
}

func (ss *S3StorageSystem) DeleteContainer(containerName string) bool {
    if ss.DebugMode {
        fmt.Printf("DeleteContainer: '%s'\n", containerName)
    }

    containerDeleted := false

    if ss.s3Session != nil {

/*
input := &s3.DeleteBucketInput{
    Bucket: aws.String(containerName),
}

result, err := svc.DeleteBucket(input)
if err != nil {
    if aerr, ok := err.(awserr.Error); ok {
        switch aerr.Code() {
        default:
            fmt.Println(aerr.Error())
        }
    } else {
        // Print the error, cast err to awserr.Error to get the Code and
        // Message from an error.
        fmt.Println(err.Error())
    }
}
*/
            containerDeleted = true
    }

    if containerDeleted {
       ss.Remove_container(containerName)
    }

    return containerDeleted
}

func (ss *S3StorageSystem) ListContainerContents(containerName string) []string {
    if ss.DebugMode {
        fmt.Printf("ListContainerContents: '%s'\n", containerName)
    }

    if ss.s3Session != nil {
        //try:
        /*
            response = s3.conn.list_objects_v2(container_name)
            meta = response['ResponseMetadata']
            status_code = meta['HTTPStatusCode']
            if status_code == 200:
                list_contents = []
                contents = response['Contents']

                for objDict in contents:
                    list_contents.append(objDict['Key'])

                return list_contents
        */
        //except Exception as exception:
        //    print("exception caught: %s" % type(exception).__name__)
        // except S3.Client.exceptions.NoSuchBucket:
        //    print("bucket does not exist")
        //    pass
    }

    return nil
}

func (ss *S3StorageSystem) GetObjectMetadata(containerName string,
                                             objectName string) *map[string]interface{} {
    if ss.DebugMode {
        fmt.Printf("GetObjectMetadata: container='%s', object='%s'\n",
                   containerName,
                   objectName)
    }

    // https://docs.aws.amazon.com/sdk-for-go/api/service/s3/#S3.HeadObject
    if ss.s3Session != nil && len(containerName) > 0 && len(objectName) > 0 {
        /*
        request := s3.HeadObjectInput{
           Bucket: &containerName,
           Key: &objectName,
        }
        response, err := ss.s3Session.HeadObject(&request)
        if err != nil {
           return nil
        } else {
           dict_headers := make(map[string]interface{})
           //if response.ArchiveStatus != nil {
           //   dict_headers["ArchiveStatus"] = *response.ArchiveStatus
           //}
           //if response.BucketKeyEnabled != nil {
           //   enabled := *response.BucketKeyEnabled
           //   var enabled_value string
	   //   if enabled {
           //      enabled_value = "true"
           //   } else {
           //      enabled_value = "false"
           //   }
	   //   dict_headers["BucketKeyEnabled"] = enabled_value
           //}
	   if response.CacheControl != nil {
              dict_headers["CacheControl"] = *response.CacheControl
           }
	   if response.ChecksumCRC32 != nil {
              dict_headers["ChecksumCRC32"] = *response.ChecksumCRC32
           }
	   if response.ChecksumCRC32C != nil {
              dict_headers["ChecksumCRC32C"] = *response.ChecksumCRC32C
           }
	   if response.ChecksumSHA1 != nil {
              dict_headers["ChecksumSHA1"] = *response.ChecksumSHA1
           }
	   if response.ChecksumSHA256 != nil {
              dict_headers["ChecksumSHA256"] = *response.ChecksumSHA256
           }
	   if response.ContentDisposition != nil {
              dict_headers["ContentDisposition"] = *response.ContentDisposition
           }
	   if response.ContentEncoding != nil {
              dict_headers["ContentEncoding"] = *response.ContentEncoding
           }
	   if response.ContentLanguage != nil {
              dict_headers["ContentLanguage"] = *response.ContentLanguage
           }
	   //if response.ContentLength != nil {
           //   //*int64
           //}
	   if response.ContentType != nil {
              dict_headers["ContentType"] = *response.ContentType
           }
	   //if response.DeleteMarker != nil {
           //   delete_marker := *response.DeleteMarker
           //   var delete_marker_value string
           //   if delete_marker {
           //      delete_marker_value = "true"
           //   } else {
           //      delete_marker_value = "false"
           //   }
	   //   dict_headers["DeleteMarker"] = delete_marker_value
           //}
	   if response.ETag != nil {
              dict_headers["ETag"] = *response.ETag
           }
	   if response.Expiration != nil {
              dict_headers["Expiration"] = *response.Expiration
           }
	   if response.Expires != nil {
              dict_headers["Expires"] = *response.Expires
           }
	   if response.LastModified != nil {
              //*time.Time
           }
	   if response.Metadata != nil {
              //map[string]*string
           }
	   //if response.MissingMeta != nil {
           //   //*int64
           //}
	   //if response.ObjectLockLegalHoldStatus != nil {
           //   dict_headers["ObjectLockLegalHoldStatus"] = *response.ObjectLockLegalHoldStatus
           //}
	   //if response.ObjectLockMode != nil {
           //   dict_headers["ObjectLockMode"] = *response.ObjectLockMode
           //}
	   if response.ObjectLockRetainUntilDate != nil {
              //*time.Time
           }
	   //if response.PartsCount != nil {
           //   dict_headers["PartsCount"] = fmt.Sprintf("%d", *response.PartsCount)
           //}
	   //if response.ReplicationStatus != nil {
           //   dict_headers["ReplicationStatus"] = *response.ReplicationStatus
           //}
	   //if response.RequestCharged != nil {
           //   dict_headers["RequestCharged"] = *response.RequestCharged
           //}
	   if response.Restore != nil {
              dict_headers["Restore"] = *response.Restore
           }
	   if response.SSECustomerAlgorithm != nil {
              dict_headers["SSECustomerAlgorithm"] = *response.SSECustomerAlgorithm
           }
	   if response.SSECustomerKeyMD5 != nil {
              dict_headers["SSECustomerKeyMD5"] = *response.SSECustomerKeyMD5
           }
	   if response.SSEKMSKeyId != nil {
              dict_headers["SSEKMSKeyId"] = *response.SSEKMSKeyId
           }
	   //if response.ServerSideEncryption != nil {
           //   dict_headers["ServerSideEncryption"] = *response.ServerSideEncryption
           //}
	   //if response.StorageClass != nil {
           //   dict_headers["StorageClass"] = *response.StorageClass
           //}
	   if response.VersionId != nil {
              dict_headers["VersionId"] = *response.VersionId
           }
	   if response.WebsiteRedirectLocation != nil {
              dict_headers["WebsiteRedirectLocation"] = *response.WebsiteRedirectLocation
           }
	   return &dict_headers
        }
	*/
    }
    return nil
}

func (ss *S3StorageSystem) PutObject(containerName string,
                                     objectName string,
                                     fileContents []byte,
                                     headers map[string]string) bool {

    objectAdded := false

    if ss.s3Session != nil && len(containerName) > 0 &&
       len(objectName) > 0 && len(fileContents) > 0 {

        /*
        bucket := containerName
        result = s3.conn.put_object(fileContents, bucket, objectName)
        if "HTTPStatusCode" in result {
            statusCode = result["HTTPStatusCode"]
            if statusCode == 200 {
                objectAdded = true
            }
        } else {
            if "ResponseMetadata" in result {
                respMeta = result["ResponseMetadata"]
                if "HTTPStatusCode" in respMeta {
                    statusCode = respMeta["HTTPStatusCode"]
                    if statusCode == 200 {
                        objectAdded = true
                    }
                }
            } else {
                //print(repr(result))
            }
        }
        */
    }

    return objectAdded
}

func (ss *S3StorageSystem) DeleteObject(containerName string, objectName string) bool {
    if ss.DebugMode {
        fmt.Printf("DeleteObject: container='%s', object='%s'\n",
                   containerName,
                   objectName)
    }

    objectDeleted := false

    if ss.s3Session != nil && len(containerName) > 0 && len(objectName) > 0 {
	    /*
       request := &s3.DeleteObjectInput{
		Bucket: &containerName,
		Key:    &objectName,
       }

       _, err := ss.s3Session.DeleteObject(request)
       if err == nil {
          objectDeleted = true
       }
       */
    }

    return objectDeleted
}

func (ss *S3StorageSystem) GetObject(containerName string,
                                     objectName string,
                                     localFilePath string) int {
    if ss.DebugMode {
        fmt.Printf("GetObject: container='%s', object='%s', localFilePath='%s'\n",
                   containerName,
                   objectName,
                   localFilePath)
    }

    bytesRetrieved := 0

    if ss.s3Session != nil && len(containerName) > 0 &&
       len(objectName) > 0 && len(localFilePath) > 0 {

        //ss.s3Session.download_file(containerName, objectName, localFilePath)
        //if FileExists(localFilePath) {
        //    bytesRetrieved = int(GetFileSize(localFilePath))
        //}
    }

    return bytesRetrieved
}

func (s3 *S3StorageSystem) AddCcontainer(containerName string) {
}

func (ss *S3StorageSystem) AddFileFromPath(containerName string,
                                           objectName string,
                                           filePath string) bool {
   return false
}

func (ss *S3StorageSystem) GetContainerNames() []string {
   names := []string{}
   return names
}

func (ss *S3StorageSystem) HasContainer(containerName string) bool {
   return false
}

func (ss *S3StorageSystem) ListContainers() []string {
   containers := []string{}
   return containers
}

func (ss *S3StorageSystem) RemoveContainer(containerName string) {
}

func (ss *S3StorageSystem) RetrieveFile(fm *FileMetadata,
                                        localDirectory string) int {
   return 0
}

func (ss *S3StorageSystem) StoreFile(fm *FileMetadata,
                                     fileContents []byte) bool {
   return false
}

